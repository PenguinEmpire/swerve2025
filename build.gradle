plugins {
    id "java"
    id "edu.wpi.first.GradleRIO" version "2025.3.1"
}

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

def ROBOT_MAIN_CLASS = "org.penguinempire.Main"

// Define my targets (RoboRIO) and artifacts (deployable files)
// This is added by GradleRIO's backing project DeployUtils.
deploy {
    targets {
        roborio(getTargetTypeClass('RoboRIO')) {
            // Team number is loaded either from the .wpilib/wpilib_preferences.json
            // or from command line. If not found an exception will be thrown.
            // You can use getTeamOrDefault(team) instead of getTeamNumber if you
            // want to store a team number in this file.
            team = project.frc.getTeamNumber()
            debug = project.frc.getDebugOrDefault(false)

            artifacts {
                // First part is artifact name, 2nd is artifact type
                // getTargetTypeClass is a shortcut to get the class type using a string

                frcJava(getArtifactTypeClass('FRCJavaArtifact')) {
                }

                // Static files artifact
                frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
                    files = project.fileTree('src/main/deploy')
                    directory = '/home/lvuser/deploy'
                    deleteOldFiles = false // Change to true to delete files on roboRIO that no
                                           // longer exist in deploy directory of this project
                }
            }
        }
    }
}

// --- Generate BuildInfo.java with Git commit + timestamp ---
task generateBuildInfo {
    def outputDir = file("$buildDir/generated/sources/buildInfo")
    def packageName = 'org.penguinempire' // ðŸ‘ˆ change to your actual package

    inputs.property "gitCommit", { "git rev-parse --short HEAD".execute().text.trim() }
    outputs.dir outputDir

    doLast {
        // Grab current commit and build time
        def gitCommit = "git rev-parse --short HEAD".execute().text.trim()
        def buildTime = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")
        def buildTimeUnix = System.currentTimeMillis() / 1000L
        // Write Java file
        def pkgDir = new File(outputDir, packageName.replace('.', '/'))
        pkgDir.mkdirs()

        def buildInfoFile = new File(pkgDir, 'BuildInfo.java')
        buildInfoFile.text = """
package ${packageName};

/** 
  * Auto-generated at build time. DO NOT EDIT. 
  * Generated at ${buildTime}
  */
@SuppressWarnings("all")
public final class BuildInfo {
    public static final String GIT_COMMIT = "${gitCommit}";
    public static final String BUILD_TIME = "${buildTime}";
    public static final double BUILD_TIME_UNIX = ${buildTimeUnix};
}"""
    }
}

task downloadLimelight {
    def limelightJavaURL = "https://github.com/LimelightVision/limelightlib-wpijava/releases/download/v1.11/LimelightHelpers.java"
    def outputDir = file("$buildDir/generated/sources/limelight")
    def packageName = 'org.limelightvision' // Limelight's package
    inputs.property 'limelightUrl', limelightJavaURL
    outputs.dir outputDir

    doLast {

        def pkgDir = new File(outputDir, packageName.replace('.', '/'))
        pkgDir.mkdirs()

        def destFile = new File(pkgDir, 'LimelightHelpers.java')
        // Does the file already exist? If so, skip download.
        if (destFile.exists()) {
            logger.lifecycle("LimelightHelpers.java already exists, skipping download.")
            return
        }
        logger.lifecycle("Downloading LimelightHelpers.java -> ${destFile.absolutePath}")

        new URL(limelightJavaURL).withInputStream { inStream ->
            destFile.withOutputStream { outStream ->
                outStream << inStream
            }
        }

        logger.lifecycle("Downloaded LimelightHelpers.java")
        // find the package line and replace it if needed
        def fileText = destFile.text

        def modifiedText = fileText.replaceFirst(
            /package\s+[^;]+;/,
            "package ${packageName};"
        )


        // After this, we need to change any occurrences of "frc.robot" to the new package
        modifiedText = modifiedText.replaceAll(
            /frc\.robot/,
            packageName
        )

        // before the line where it says 'public class LimelightHelpers {', add @SuppressWarnings("all")
        // We DO NOT want to edit this file in any capacity so we don't know any warnings.
        modifiedText = modifiedText.replaceFirst(
            /public\s+class\s+LimelightHelpers\s*\{/,
            "@SuppressWarnings(\"all\") // @generated - Ignore all warnings because this is a generated file.\npublic class LimelightHelpers {"
        )
        // write back the modified text
        destFile.text = """// WARNING!
// --> THIS IS AN AUTOMATICALLY GENERATED FILE.
// --> ANY CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN, AND WILL NOT BE PRESERVED.

// AGAIN, DO. NOT. EDIT. THIS. FILE.
// downloaded-from: ${limelightJavaURL}
// downloaded-at: ${new Date().format("yyyy-MM-dd 'at' hh:mm:ss a")}

$modifiedText"""
    }
}

// --- Hook into the Java build process ---
compileJava.dependsOn generateBuildInfo
compileJava.dependsOn downloadLimelight

sourceSets.main.java.srcDir "$buildDir/generated/sources/limelight" // org.limelightvision.LimelightHelpers
sourceSets.main.java.srcDir "$buildDir/generated/sources/buildInfo" // org.penguinempire.BuildInfo

def deployArtifact = deploy.targets.roborio.artifacts.frcJava

// Set to true to use debug for JNI.
wpi.java.debugJni = false

// Set this to true to enable desktop support.
def includeDesktopSupport = true

// Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
// Also defines JUnit 5.
dependencies {
    annotationProcessor wpi.java.deps.wpilibAnnotations()
    implementation wpi.java.deps.wpilib()
    implementation wpi.java.vendor.java()

    roborioDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.roborio)
    roborioDebug wpi.java.vendor.jniDebug(wpi.platforms.roborio)

    roborioRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.roborio)
    roborioRelease wpi.java.vendor.jniRelease(wpi.platforms.roborio)

    nativeDebug wpi.java.deps.wpilibJniDebug(wpi.platforms.desktop)
    nativeDebug wpi.java.vendor.jniDebug(wpi.platforms.desktop)
    simulationDebug wpi.sim.enableDebug()

    nativeRelease wpi.java.deps.wpilibJniRelease(wpi.platforms.desktop)
    nativeRelease wpi.java.vendor.jniRelease(wpi.platforms.desktop)
    simulationRelease wpi.sim.enableRelease()

    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

test {
    useJUnitPlatform()
    systemProperty 'junit.jupiter.extensions.autodetection.enabled', 'true'
}

// Simulation configuration (e.g. environment variables).
wpi.sim.addGui().defaultEnabled = true
wpi.sim.addDriverstation()

// Setting up my Jar File. In this case, adding all libraries into the main jar ('fat jar')
// in order to make them all available at runtime. Also adding the manifest so WPILib
// knows where to look for our Robot Class.
jar {
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    from sourceSets.main.allSource
    manifest edu.wpi.first.gradlerio.GradleRIOPlugin.javaManifest(ROBOT_MAIN_CLASS)
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

// Configure jar and deploy tasks
deployArtifact.jarTask = jar
wpi.java.configureExecutableTasks(jar)
wpi.java.configureTestTasks(test)

// Configure string concat to always inline compile
tasks.withType(JavaCompile) {
    options.compilerArgs.add '-XDstringConcat=inline'
}
